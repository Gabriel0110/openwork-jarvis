import { describe, expect, it } from "vitest"
import { collectTriggerMatchCandidates } from "../../src/main/services/template-trigger-runtime"
import type { TimelineEvent, WorkflowTemplate } from "../../src/main/types"

function buildTemplate(overrides?: Partial<WorkflowTemplate>): WorkflowTemplate {
  return {
    id: "tpl-1",
    workspaceId: "default-workspace",
    name: "Research Digest",
    description: "digest",
    starterPrompts: [],
    agentIds: [],
    requiredConnectorKeys: [],
    expectedArtifacts: [],
    defaultSpeakerType: "orchestrator",
    policyDefaults: [],
    memoryDefaults: {},
    schedule: undefined,
    triggers: [],
    tags: [],
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides
  }
}

function buildEvent(overrides?: Partial<TimelineEvent>): TimelineEvent {
  return {
    id: "evt-1",
    threadId: "thread-1",
    workspaceId: "default-workspace",
    eventType: "tool_result",
    sourceAgentId: "agent-1",
    toolName: "github",
    summary: "build succeeded",
    payload: {},
    occurredAt: new Date(),
    createdAt: new Date(),
    ...overrides
  }
}

describe("collectTriggerMatchCandidates", () => {
  it("matches enabled timeline triggers by event type", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-1",
          type: "timeline_event",
          enabled: true,
          executionMode: "notify",
          eventKey: "tool_result"
        }
      ]
    })

    const candidates = collectTriggerMatchCandidates(buildEvent(), [template])
    expect(candidates).toHaveLength(1)
    expect(candidates[0].toolName).toBe("template:trigger")
    expect(candidates[0].payload.templateId).toBe("tpl-1")
    expect(candidates[0].autoRunEligible).toBe(false)
  })

  it("respects sourceKey and matchText filters", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-2",
          type: "timeline_event",
          enabled: true,
          executionMode: "notify",
          eventKey: "tool_result",
          sourceKey: "github",
          matchText: "succeeded"
        }
      ]
    })

    const matching = collectTriggerMatchCandidates(buildEvent(), [template])
    const nonMatchingSource = collectTriggerMatchCandidates(buildEvent({ toolName: "jira" }), [
      template
    ])
    const nonMatchingText = collectTriggerMatchCandidates(buildEvent({ summary: "build failed" }), [
      template
    ])

    expect(matching).toHaveLength(1)
    expect(nonMatchingSource).toHaveLength(0)
    expect(nonMatchingText).toHaveLength(0)
  })

  it("ignores trigger events generated by matcher itself", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-3",
          type: "timeline_event",
          enabled: true,
          executionMode: "notify",
          eventKey: "template_trigger_match"
        }
      ]
    })

    const candidates = collectTriggerMatchCandidates(
      buildEvent({ eventType: "template_trigger_match" }),
      [template]
    )
    expect(candidates).toHaveLength(0)
  })

  it("marks auto-run eligible triggers and blocks template system tool events", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-4",
          type: "timeline_event",
          enabled: true,
          executionMode: "auto_run",
          eventKey: "tool_result"
        }
      ]
    })

    const regularCandidates = collectTriggerMatchCandidates(buildEvent({ toolName: "github" }), [
      template
    ])
    const systemCandidates = collectTriggerMatchCandidates(
      buildEvent({ toolName: "template:run" }),
      [template]
    )

    expect(regularCandidates).toHaveLength(1)
    expect(regularCandidates[0].autoRunEligible).toBe(true)
    expect(regularCandidates[0].payload.status).toBe("auto_run_pending")
    expect(systemCandidates).toHaveLength(0)
  })

  it("matches connector_event triggers using connector key + event key", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-5",
          type: "connector_event",
          enabled: true,
          executionMode: "notify",
          eventKey: "tool_call",
          sourceKey: "github"
        }
      ]
    })

    const connectorEvent = buildEvent({
      eventType: "tool_call",
      toolName: "connector:github",
      payload: {
        args: {
          connectorKey: "github"
        }
      }
    })
    const nonConnectorEvent = buildEvent({
      eventType: "tool_call",
      toolName: "execute"
    })

    const matched = collectTriggerMatchCandidates(connectorEvent, [template])
    const nonMatched = collectTriggerMatchCandidates(nonConnectorEvent, [template])

    expect(matched).toHaveLength(1)
    expect(matched[0].payload.triggerType).toBe("connector_event")
    expect(nonMatched).toHaveLength(0)
  })

  it("matches webhook triggers from payload event/source metadata", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-6",
          type: "webhook",
          enabled: true,
          executionMode: "notify",
          eventKey: "order.created",
          sourceKey: "stripe"
        }
      ]
    })

    const webhookEvent = buildEvent({
      eventType: "tool_result",
      toolName: "connector:webhook",
      payload: {
        webhookEventKey: "order.created",
        webhookSource: "stripe"
      }
    })
    const wrongSource = buildEvent({
      eventType: "tool_result",
      toolName: "connector:webhook",
      payload: {
        webhookEventKey: "order.created",
        webhookSource: "shopify"
      }
    })

    const matched = collectTriggerMatchCandidates(webhookEvent, [template])
    const nonMatched = collectTriggerMatchCandidates(wrongSource, [template])

    expect(matched).toHaveLength(1)
    expect(matched[0].payload.triggerType).toBe("webhook")
    expect(nonMatched).toHaveLength(0)
  })

  it("keeps auto_run disabled for non-timeline trigger types", () => {
    const template = buildTemplate({
      triggers: [
        {
          id: "trig-7",
          type: "connector_event",
          enabled: true,
          executionMode: "auto_run",
          eventKey: "tool_call",
          sourceKey: "github"
        }
      ]
    })

    const connectorEvent = buildEvent({
      eventType: "tool_call",
      toolName: "connector:github",
      payload: {
        args: {
          connectorKey: "github"
        }
      }
    })

    const matched = collectTriggerMatchCandidates(connectorEvent, [template])
    expect(matched).toHaveLength(1)
    expect(matched[0].autoRunEligible).toBe(false)
    expect(matched[0].payload.status).toBe("notify_pending")
  })
})
